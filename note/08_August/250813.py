"""
[250813]

<알고리즘 라이브 강의>

Stack
- 사용
    0. 괄호 검사
    1. Function Call
    2. 비선형구조(그래프)에서 모든 자료를 빠짐없이 검색하기 위한 탐색
        * DFS(Depth First Search) : 재귀호출 혹은 Stack을 이용하여 한 방향으로 가능한 깊게 탐색한 후, 더 이상 갈 곳이 없으면 되돌아와 다른 방향을 탐색하는 방법
        ※ BFS(Breadth First Search) : Queue를 이용하여 현재 노드에서 방문할 수 있는 인접한 노드를 모두 탐색하는 방법

재귀호출 : 함수가 자신과 같은 작업을 반복할 때, 자신을 다시 호출하는 구조로 프로그램의 크기를 줄이고 간단하게 작성이 가능
>> 중복 호출이 다수 발생할 수 있음
    >> Memoization : DP의 핵심이 되는 기술로 동일한 계산을 반복해야 할 때, 이전의 계산값을 저장하고 이를 재사용하는 것으로 효율성을 높임

Dynamic Programming(동적 계획법) : 작은 부분 문제들을 먼저 해결한 뒤 그 결과를 통해 더 큰 부분 문제를 순차적으로 해결하는 알고리즘
    >> 완전탐색과 같이 모든 문제를 해결함 (다만 그 해결에 있어, 앞서 생성된 결과를 이용 - 효율적인 완전탐색)
       즉, 최적 해가 하위 문제의 최적 해로부터 쉽게 구성될 수 있는 '최적 부분 구조'여야 하며
       동일한 하위 문제가 다수 반복되어 나타나는 '중복 부분 문제'여야 함

※ Memoization [하향식 DP] : 재귀함수를 사용하여 큰 문제에 대한 작은 재귀함수를 호출하고 각 차례의 값을 기억하여 재사용
※ Tabulation [상향식 DP] : 반복문을 사용하여 작은 문제에 대한 DP Table을 생성하고 이를 바탕으로 큰 문제의 해를 반복적으로 생성


<실습>

DP : 최적화(최소/최댓값을 구하는) 문제 해결을 위한 효율적인 완전탐색 알고리즘
>> 큰 문제를 작은 문제로 분절하여, 작은 문제 최적 해의 조합을 통해 큰 문제의 최적 해를 구하는 것
- 최적 부분 구조: 작은 문제의 최적 해가 큰 문제의 최적 해와 같이 존재하는 경우
- 중복 부분 문제: 작은 문제가 중복해서 출현하는 경우

그래프 : 정점(vertex)와 간선(edge)로 이루어진 비선형 자료구조
- 표현 방법
    1. 인접 행렬
        ex) graph[start][end] = True / False
           |0  |1  |2  |3
        ------------------
        0  |0  |1  |1  |1
        ------------------
        1  |1  |0  |1  |0
        ------------------
        2  |1  |1  |0  |1
        ------------------
        3  |1  |0  |1  |0
        ------------------
    2. 인접 리스트
        ex) graph[start] = [can go vertexes]
    3. 간선 리스트
        ex) arr = [(start_0, end_0), ... (start_N, end_N)]
"""